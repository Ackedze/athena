{
  "version": 3,
  "sources": ["../src/engine/component/utils/inferCategory.ts", "../src/engine/component/utils/makePath.ts", "../src/engine/component/extract/extractStyles.ts", "../src/engine/component/extract/extractLayout.ts", "../src/engine/component/extract/extractText.ts", "../src/engine/component/extract/extractInstance.ts", "../src/engine/component/extract/extractRadius.ts", "../src/engine/component/extract/extractEffects.ts", "../src/engine/component/snapshotNode.ts", "../src/engine/component/collectStructure.ts", "../src/engine/component/variantParser.ts", "../src/lib/componentMetaClassifier.ts", "../src/engine/component/utils/getSectionName.ts", "../src/engine/component/describeComponentSet.ts", "../src/engine/component/describeSingleComponent.ts", "../src/debug.ts", "../src/engine/component/componentParser.ts", "../src/code.ts"],
  "sourcesContent": ["export function inferCategoryFromName(name: string): string {\n  const cleaned = name.replace(/^[^\\w\u0410-\u042F\u0430-\u044F]+/, \"\").trim();\n  const parts = cleaned.split(\"/\").map((p) => p.trim());\n  return parts[0] || \"Uncategorized\";\n}\n", "export function makePath(parent: string, name: string): string {\n  return parent ? parent + \" / \" + name : name;\n}\n", "import { DSNodeStyles, DSTokenReference } from \"../../types\";\n\nexport function extractStyles(node: SceneNode): DSNodeStyles | undefined {\n  const styles: DSNodeStyles = {};\n\n  if (\"fillStyleId\" in node) {\n    const ref = makeRef(node.fillStyleId as any);\n    if (ref) {\n      styles.fill = ref;\n    }\n  }\n  if (\"strokeStyleId\" in node) {\n    const ref = makeRef(node.strokeStyleId as any);\n    if (ref) {\n      styles.stroke = ref;\n    }\n  }\n\n  if (node.type === \"TEXT\") {\n    const textNode = node as TextNode;\n    const ref = makeRef(textNode.textStyleId as any);\n    if (ref) {\n      styles.text = ref;\n    }\n  }\n\n  if (\"effectStyleId\" in node) {\n    const ref = makeRef((node as any).effectStyleId);\n    if (ref) styles.effects = [ref];\n  }\n\n  return Object.keys(styles).length ? styles : undefined;\n}\n\nfunction makeRef(styleId: string | typeof figma.mixed): DSTokenReference | null {\n  if (!styleId || styleId === figma.mixed) return null;\n  return { styleKey: String(styleId) };\n}\n", "import { DSNodeLayout } from \"../../types\";\n\nexport function extractLayout(node: SceneNode): DSNodeLayout | undefined {\n  // \u0421\u043D\u0438\u043C\u0430\u0435\u043C \u0442\u043E\u043B\u044C\u043A\u043E auto-layout settings \u0438 bound variable tokens.\n  const layout: DSNodeLayout = {};\n\n  if (\"layoutMode\" in node && node.layoutMode && node.layoutMode !== \"NONE\") {\n    const padding = {\n      top: node.paddingTop || 0,\n      right: node.paddingRight || 0,\n      bottom: node.paddingBottom || 0,\n      left: node.paddingLeft || 0,\n    };\n    layout.padding = padding;\n    if (typeof node.itemSpacing === \"number\") {\n      layout.itemSpacing = node.itemSpacing;\n    }\n    const bound = (node as any).boundVariables;\n    const paddingTokens = {\n      top: getBoundVariableId(bound, \"paddingTop\"),\n      right: getBoundVariableId(bound, \"paddingRight\"),\n      bottom: getBoundVariableId(bound, \"paddingBottom\"),\n      left: getBoundVariableId(bound, \"paddingLeft\"),\n    };\n    if (\n      paddingTokens.top ||\n      paddingTokens.right ||\n      paddingTokens.bottom ||\n      paddingTokens.left\n    ) {\n      layout.paddingTokens = paddingTokens;\n    }\n    const itemSpacingToken = getBoundVariableId(bound, \"itemSpacing\");\n    if (itemSpacingToken) {\n      layout.itemSpacingToken = itemSpacingToken;\n    }\n  }\n\n  return Object.keys(layout).length ? layout : undefined;\n}\n\nfunction getBoundVariableId(boundVariables: any, key: string): string | null {\n  if (!boundVariables) return null;\n  const binding = boundVariables[key];\n  if (!binding) return null;\n  if (Array.isArray(binding)) {\n    for (const item of binding) {\n      const candidate = resolveBindingId(item);\n      if (candidate) return candidate;\n    }\n    return null;\n  }\n  return resolveBindingId(binding);\n}\n\nfunction resolveBindingId(binding: any): string | null {\n  if (!binding) return null;\n  if (typeof binding === \"string\") return binding;\n  const candidate =\n    binding.id ||\n    binding.variableId ||\n    binding.variable?.id ||\n    binding.variable?.key;\n  if (candidate) return String(candidate);\n  const nested =\n    binding.boundVariables?.color ||\n    binding.boundVariables?.fills ||\n    binding.boundVariables?.fill ||\n    binding.boundVariables?.strokes ||\n    binding.boundVariables?.stroke;\n  if (nested) return resolveBindingId(nested);\n  return null;\n}\n", "import { DSTextContent } from \"../../types\";\n\nexport function extractText(node: SceneNode): DSTextContent | undefined {\n  // \u041F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u0435\u043C mixed values, \u0447\u0442\u043E\u0431\u044B \u0438\u0437\u0431\u0435\u0436\u0430\u0442\u044C partial range extraction.\n  if (node.type !== \"TEXT\") return undefined;\n\n  const t = node as TextNode;\n  const result: DSTextContent = {};\n  let hasData = false;\n\n  if (typeof t.characters === \"string\" && t.characters.length) {\n    result.characters = t.characters;\n    hasData = true;\n  }\n\n  if (t.fontName !== figma.mixed) {\n    const fontName = t.fontName;\n    result.fontName = `${fontName.family} ${fontName.style}`.trim();\n    hasData = true;\n  }\n\n  if (t.fontSize !== figma.mixed && typeof t.fontSize === \"number\") {\n    result.fontSize = t.fontSize;\n    hasData = true;\n  }\n\n  if (t.lineHeight !== figma.mixed && t.lineHeight) {\n    if (t.lineHeight.unit === \"PIXELS\") {\n      result.lineHeight = t.lineHeight.value;\n    } else {\n      result.lineHeight = t.lineHeight.unit + \"(\" + t.lineHeight.value + \")\";\n    }\n    hasData = true;\n  }\n\n  if (t.letterSpacing !== figma.mixed && t.letterSpacing) {\n    result.letterSpacing = t.letterSpacing.value;\n    hasData = true;\n  }\n\n  if (typeof t.paragraphSpacing === \"number\") {\n    result.paragraphSpacing = t.paragraphSpacing;\n    hasData = true;\n  }\n\n  if (t.textCase && t.textCase !== \"ORIGINAL\") {\n    result.case = t.textCase;\n    hasData = true;\n  }\n\n  return hasData ? result : undefined;\n}\n", "import { DSInstanceInfo } from \"../../types\";\n\nexport function extractInstance(node: SceneNode): DSInstanceInfo | undefined {\n  if (node.type !== \"INSTANCE\") return undefined;\n\n  const inst = node as InstanceNode;\n  const main = inst.mainComponent;\n  if (!main) return undefined;\n\n  const info: DSInstanceInfo = {\n    componentKey: main.key,\n  };\n\n  const vp = (inst as any).variantProperties;\n  if (vp && typeof vp === \"object\") {\n    info.variantProperties = vp as Record<string, string>;\n  }\n\n  return info;\n}\n", "import { DSRadii } from \"../../types\";\n\nexport function extractRadius(node: SceneNode): DSRadii | undefined {\n  if (\"cornerRadius\" in node) {\n    if (node.cornerRadius !== figma.mixed && typeof node.cornerRadius === \"number\") {\n      return node.cornerRadius;\n    }\n\n    if (\n      \"topLeftRadius\" in node &&\n      typeof node.topLeftRadius === \"number\" &&\n      typeof node.topRightRadius === \"number\" &&\n      typeof node.bottomRightRadius === \"number\" &&\n      typeof node.bottomLeftRadius === \"number\"\n    ) {\n      return {\n        topLeft: node.topLeftRadius,\n        topRight: node.topRightRadius,\n        bottomRight: node.bottomRightRadius,\n        bottomLeft: node.bottomLeftRadius,\n      };\n    }\n  }\n\n  return undefined;\n}\n", "import { DSEffect } from \"../../types\";\n\nexport function extractEffects(node: SceneNode): DSEffect[] | undefined {\n  if (!(\"effects\" in node)) return undefined;\n  const effects = node.effects;\n  if (!effects || effects === figma.mixed || effects.length === 0) return undefined;\n\n  const result: DSEffect[] = [];\n\n  for (const e of effects) {\n    if (\n      e.type === \"DROP_SHADOW\" ||\n      e.type === \"INNER_SHADOW\" ||\n      e.type === \"LAYER_BLUR\" ||\n      e.type === \"BACKGROUND_BLUR\"\n    ) {\n      const eff: DSEffect = {\n        type: e.type,\n        radius: e.radius,\n      };\n\n      if (\"color\" in e && e.color) {\n        eff.color = `rgba(${Math.round(e.color.r * 255)}, ${Math.round(\n          e.color.g * 255\n        )}, ${Math.round(e.color.b * 255)}, ${e.color.a.toFixed(2)})`;\n      }\n\n      if (\"offset\" in e && e.offset) {\n        eff.offset = { x: e.offset.x, y: e.offset.y };\n      }\n\n      result.push(eff);\n    }\n  }\n\n  return result.length ? result : undefined;\n}\n", "import { DSStructureNode, DSPaint, DSTypography } from \"../types\";\nimport { makePath } from \"./utils/makePath\";\nimport { extractStyles } from \"./extract/extractStyles\";\nimport { extractLayout } from \"./extract/extractLayout\";\nimport { extractText } from \"./extract/extractText\";\nimport { extractInstance } from \"./extract/extractInstance\";\nimport { extractRadius } from \"./extract/extractRadius\";\nimport { extractEffects } from \"./extract/extractEffects\";\n\ninterface SnapshotOptions {\n  preserveHiddenFills?: boolean;\n}\n\nexport function snapshotNode(\n  node: SceneNode,\n  parentPath: string,\n  parentId: number | null,\n  id: number,\n  options?: SnapshotOptions,\n): DSStructureNode {\n  // \u0414\u0435\u043B\u0430\u0435\u043C snapshot structural \u0438 visual properties \u0434\u043B\u044F export.\n  const path = makePath(parentPath, node.name);\n\n  const snap: DSStructureNode = {\n    id,\n    parentId,\n    path,\n    type: node.type,\n    name: node.name,\n    visible: node.visible,\n  };\n\n  const styles = extractStyles(node);\n  if (styles) {\n    snap.styles = styles;\n  }\n\n  const layout = extractLayout(node);\n  if (layout) {\n    snap.layout = layout;\n  }\n\n  if (\"opacity\" in node && typeof node.opacity === \"number\") {\n    snap.opacity = node.opacity;\n  }\n  const bound = (node as any).boundVariables;\n  const opacityToken = getBoundVariableId(bound, \"opacity\");\n  if (opacityToken) {\n    snap.opacityToken = opacityToken;\n  }\n\n  const snapshotOptions = {\n    preserveHiddenFills: options?.preserveHiddenFills ?? true,\n  };\n\n  // Resolve paint tokens \u0447\u0435\u0440\u0435\u0437 bound variables \u0438\u043B\u0438 styles, \u0437\u0430\u0442\u0435\u043C attach paint data.\n  const rawFills = \"fills\" in node ? node.fills : undefined;\n  const fillToken =\n    extractPaintVariableId(rawFills) ||\n    getBoundVariableId(bound, \"fills\") ||\n    getBoundVariableId(bound, \"fill\") ||\n    extractPaintVariableIdFromStyle(node, \"fillStyleId\") ||\n    null;\n  const textStyleFillToken =\n    !fillToken && node.type === \"TEXT\"\n      ? extractPaintVariableIdFromTextStyle(node as TextNode)\n      : null;\n  const resolvedFillToken = fillToken || textStyleFillToken;\n  const shouldCaptureFills = snapshotOptions.preserveHiddenFills || node.visible;\n  const fills = shouldCaptureFills\n    ? extractPaints(rawFills, { tokenKey: resolvedFillToken })\n    : null;\n  if (fills) {\n    snap.fills = fills;\n  }\n  if (resolvedFillToken) {\n    snap.fillToken = resolvedFillToken;\n  }\n\n  const rawStrokes = \"strokes\" in node ? node.strokes : undefined;\n  const strokeToken =\n    extractPaintVariableId(rawStrokes) ||\n    getBoundVariableId(bound, \"strokes\") ||\n    getBoundVariableId(bound, \"stroke\") ||\n    extractPaintVariableIdFromStyle(node, \"strokeStyleId\") ||\n    null;\n  const strokes = extractPaints(rawStrokes, { tokenKey: strokeToken });\n  const strokeWeight =\n    \"strokeWeight\" in node && typeof node.strokeWeight === \"number\"\n      ? node.strokeWeight\n      : null;\n\n  if (strokes && strokes.length > 0) {\n    snap.strokes = strokes;\n    if (typeof strokeWeight === \"number\") {\n      snap.strokeWeight = strokeWeight;\n    }\n    if (node.strokeAlign) {\n      snap.strokeAlign = node.strokeAlign;\n    }\n  }\n  if (strokeToken) {\n    snap.strokeToken = strokeToken;\n  }\n\n  const inst = extractInstance(node);\n  if (inst) snap.componentInstance = inst;\n\n  const text = extractText(node);\n  if (text) snap.text = text;\n\n  const typography = extractTypography(node);\n  if (typography) snap.typography = typography;\n  if (node.type === \"TEXT\") {\n    const typographyToken =\n      getBoundVariableId(bound, \"fontSize\") ||\n      getBoundVariableId(bound, \"lineHeight\") ||\n      getBoundVariableId(bound, \"letterSpacing\");\n    if (typographyToken) {\n      snap.typographyToken = typographyToken;\n    }\n  }\n\n  const radius = extractRadius(node);\n  if (typeof radius !== \"undefined\") {\n    snap.radius = radius;\n  }\n  const radiusToken = getBoundVariableId(bound, \"cornerRadius\");\n  if (radiusToken) {\n    snap.radiusToken = radiusToken;\n  }\n\n  const effects = extractEffects(node);\n  if (effects && effects.length > 0) {\n    snap.effects = effects;\n  }\n\n  return snap;\n}\n\nfunction extractPaints(\n  paints: readonly Paint[] | PluginAPI[\"mixed\"] | undefined,\n  options?: { tokenKey?: string | null },\n): DSPaint[] | null {\n  if (!paints || paints === figma.mixed || !Array.isArray(paints)) {\n    return null;\n  }\n  const solids = paints.filter((paint) => paint.type === \"SOLID\");\n  if (!solids.length) {\n    return null;\n  }\n  return solids.map((paint) => {\n    const color = paint.color;\n    const opacity = paint.opacity === undefined ? 1 : paint.opacity;\n    return {\n      type: \"SOLID\",\n      color: {\n        r: Math.round(color.r * 255),\n        g: Math.round(color.g * 255),\n        b: Math.round(color.b * 255),\n        a: Math.round(opacity * 100) / 100,\n      },\n      visible: paint.visible,\n      opacity,\n      tokenKey: options?.tokenKey ?? null,\n      colorHex: paintColorToHex(color),\n    };\n  });\n}\n\nfunction extractTypography(node: SceneNode): DSTypography | null {\n  if (node.type !== \"TEXT\") return null;\n  const textNode = node as TextNode;\n  if (textNode.fontName === figma.mixed) {\n    return null;\n  }\n  const fontName = textNode.fontName;\n  const typography: DSTypography = {\n    fontName: `${fontName.family} ${fontName.style}`.trim(),\n  };\n  if (textNode.fontSize !== figma.mixed && typeof textNode.fontSize === \"number\") {\n    typography.fontSize = textNode.fontSize;\n  }\n  return Object.keys(typography).length ? typography : null;\n}\n\nfunction extractPaintVariableId(\n  paints: readonly Paint[] | PluginAPI[\"mixed\"] | undefined,\n): string | null {\n  if (!paints || paints === figma.mixed || !Array.isArray(paints)) {\n    return null;\n  }\n  for (const paint of paints) {\n    if (!paint || paint.type !== \"SOLID\") continue;\n    const bound = (paint as any).boundVariables;\n    const direct =\n      resolveBindingId(bound?.color) ||\n      resolveBindingId(bound?.fill) ||\n      resolveBindingId(bound?.fills);\n    if (direct) return direct;\n    if (bound && typeof bound === \"object\") {\n      for (const value of Object.values(bound)) {\n        const candidate = resolveBindingId(value);\n        if (candidate) return candidate;\n      }\n    }\n  }\n  return null;\n}\n\nfunction extractPaintVariableIdFromStyle(\n  node: SceneNode,\n  styleKey: \"fillStyleId\" | \"strokeStyleId\",\n): string | null {\n  const styleId = (node as any)[styleKey];\n  if (!styleId || styleId === figma.mixed || typeof styleId !== \"string\") {\n    return null;\n  }\n  const style = figma.getStyleById(styleId) as PaintStyle | null;\n  if (!style) return null;\n  const boundToken = extractVariableIdFromStyleBoundVariables(style);\n  if (boundToken) return boundToken;\n  if (!(\"paints\" in style)) return null;\n  return extractPaintVariableId((style as PaintStyle).paints);\n}\n\nfunction extractPaintVariableIdFromTextStyle(node: TextNode): string | null {\n  const styleId = node.textStyleId;\n  if (!styleId || styleId === figma.mixed || typeof styleId !== \"string\") {\n    return null;\n  }\n  const style = figma.getStyleById(styleId) as TextStyle | null;\n  if (!style) return null;\n  const boundToken = extractVariableIdFromStyleBoundVariables(style);\n  if (boundToken) return boundToken;\n  if (!(\"fills\" in style)) return null;\n  return extractPaintVariableId((style as TextStyle).fills);\n}\n\nfunction extractVariableIdFromStyleBoundVariables(style: any): string | null {\n  const bound = style?.boundVariables;\n  const direct =\n    getBoundVariableId(bound, \"color\") ||\n    getBoundVariableId(bound, \"fills\") ||\n    getBoundVariableId(bound, \"fill\") ||\n    getBoundVariableId(bound, \"strokes\") ||\n    getBoundVariableId(bound, \"stroke\");\n  if (direct) return direct;\n  if (!bound || typeof bound !== \"object\") return null;\n  for (const value of Object.values(bound)) {\n    const candidate = resolveBindingId(value);\n    if (candidate) return candidate;\n  }\n  return null;\n}\n\nfunction getBoundVariableId(boundVariables: any, key: string): string | null {\n  if (!boundVariables) return null;\n  const binding = boundVariables[key];\n  if (!binding) return null;\n  if (Array.isArray(binding)) {\n    for (const item of binding) {\n      const candidate = resolveBindingId(item);\n      if (candidate) return candidate;\n    }\n    return null;\n  }\n  return resolveBindingId(binding);\n}\n\nfunction resolveBindingId(binding: any): string | null {\n  if (!binding) return null;\n  if (typeof binding === \"string\") return binding;\n  const candidate =\n    binding.id ||\n    binding.variableId ||\n    binding.variable?.id ||\n    binding.variable?.key;\n  if (candidate) return String(candidate);\n  const nested =\n    binding.value ||\n    binding.values ||\n    binding.alias ||\n    binding.variableAlias;\n  if (nested) return resolveBindingId(nested);\n  const nestedVars =\n    binding.boundVariables?.color ||\n    binding.boundVariables?.fills ||\n    binding.boundVariables?.fill ||\n    binding.boundVariables?.strokes ||\n    binding.boundVariables?.stroke;\n  if (nestedVars) return resolveBindingId(nestedVars);\n  return null;\n}\n\nfunction paintColorToHex(color: RGB): string {\n  const r = clampColorComponent(color.r);\n  const g = clampColorComponent(color.g);\n  const b = clampColorComponent(color.b);\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n}\n\nfunction clampColorComponent(value: number | undefined): number {\n  const normalized = typeof value === \"number\" ? value : 0;\n  const scaled = Math.round(normalized * 255);\n  if (scaled <= 0) {\n    return 0;\n  }\n  if (scaled >= 255) {\n    return 255;\n  }\n  return scaled;\n}\n\nfunction toHex(component: number): string {\n  const hex = component.toString(16).toUpperCase();\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n", "import { DSStructureNode } from \"../types\";\nimport { snapshotNode } from \"./snapshotNode\";\n\ninterface CollectStructureOptions {\n  preserveHiddenFills?: boolean;\n}\n\n// Cache per root node + options, \u0447\u0442\u043E\u0431\u044B \u043D\u0435 \u043F\u0435\u0440\u0435\u0441\u043E\u0431\u0438\u0440\u0430\u0442\u044C \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u044B \u043C\u0435\u0436\u0434\u0443 variants.\nconst structureCache = new Map<string, DSStructureNode[]>();\n\nexport function resetStructureCache() {\n  structureCache.clear();\n}\n\nexport function collectComponentStructure(\n  root: SceneNode,\n  options?: CollectStructureOptions,\n): DSStructureNode[] {\n  const resolvedOptions = {\n    preserveHiddenFills: options?.preserveHiddenFills ?? true,\n  };\n  const cacheKey = `${root.id}:${resolvedOptions.preserveHiddenFills ? \"1\" : \"0\"}`;\n  const cached = structureCache.get(cacheKey);\n  if (cached) {\n    return cached;\n  }\n\n  const list: DSStructureNode[] = [];\n  let nextId = 1;\n\n  function walk(node: SceneNode, parentPath: string, parentId: number | null) {\n    const id = nextId++;\n    const snap = snapshotNode(node, parentPath, parentId, id, resolvedOptions);\n    list.push(snap);\n\n    if (\"children\" in node) {\n      for (const child of node.children as SceneNode[]) {\n        walk(child, snap.path, id);\n      }\n    }\n  }\n\n  walk(root, \"\", null);\n  structureCache.set(cacheKey, list);\n  return list;\n}\n", "import { DSVariant } from \"../types\";\n\nexport function extractVariantList(set: ComponentSetNode): DSVariant[] {\n  const result: DSVariant[] = [];\n\n  for (const child of set.children) {\n    if (child.type !== \"COMPONENT\") continue;\n\n    result.push({\n      id: child.id,\n      key: child.key,\n      name: child.name,\n    });\n  }\n\n  return result;\n}\n", "// src/lib/componentMetaClassifier.ts\n\nimport type {\n  ComponentPlatform,\n  ComponentRole,\n  ComponentStatus,\n} from '../engine/types';\n\nexport interface ComponentClassificationContext {\n  /**\n   * \u0418\u043C\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430 \u0432 \u0444\u0438\u0433\u043C\u0435, \u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440:\n   * \"[D] BenefitCard\", \"Onboarding Tooltip \u274C\", \"\uD83D\uDD29 Parts / Button\"\n   */\n  componentName: string;\n\n  /**\n   * \u0418\u043C\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B, \u0435\u0441\u043B\u0438 \u043D\u0443\u0436\u043D\u043E \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C \u0435\u0451 \u043F\u0430\u0442\u0442\u0435\u0440\u043D\u044B\n   * \u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \"Onboarding Tooltip [D]\"\n   */\n  pageName?: string | null;\n\n  /**\n   * \u0418\u043C\u044F \u0441\u0435\u043A\u0446\u0438\u0438 / \u0444\u0440\u0435\u0439\u043C\u0430 \u0432\u0435\u0440\u0445\u043D\u0435\u0433\u043E \u0443\u0440\u043E\u0432\u043D\u044F,\n   * \u0433\u0434\u0435 \u043B\u0435\u0436\u0438\u0442 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 (\u0435\u0441\u043B\u0438 \u0442\u044B \u0435\u0433\u043E \u043F\u0440\u043E\u0431\u0440\u0430\u0441\u044B\u0432\u0430\u0435\u0448\u044C).\n   * \u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \"\uD83D\uDD29 Parts\", \"\u274C Deprecated\", \"\uD83D\uDD04 To be removed\"\n   */\n  sectionName?: string | null;\n\n  /**\n   * \u0418\u043C\u044F \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438 (\u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430), \u0435\u0441\u043B\u0438 \u043D\u0443\u0436\u043D\u043E \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C \u0435\u0451 \u043C\u0435\u0442\u043A\u0438.\n   */\n  libraryName?: string | null;\n}\n\nexport interface ComponentClassificationResult {\n  role: ComponentRole;\n  status: ComponentStatus;\n  platform: ComponentPlatform;\n}\n\n/**\n * \u041A\u043B\u0430\u0441\u0441\u0438\u0444\u0438\u0446\u0438\u0440\u0443\u0435\u043C \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 \u043F\u043E \u0440\u043E\u043B\u0438 \u0438 \u0441\u0442\u0430\u0442\u0443\u0441\u0443\n * \u043D\u0430 \u043E\u0441\u043D\u043E\u0432\u0435 \u0438\u043C\u0435\u043D\u0438 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430, \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B \u0438 \u0441\u0435\u043A\u0446\u0438\u0438.\n */\nexport function classifyComponentMeta(\n  ctx: ComponentClassificationContext,\n): ComponentClassificationResult {\n  // Simple heuristics \u043D\u0430 \u043E\u0441\u043D\u043E\u0432\u0435 naming conventions; \u043F\u043E\u0434\u0441\u0442\u0440\u043E\u0439\u0442\u0435, \u043A\u043E\u0433\u0434\u0430 taxonomy \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u0441\u044F.\n  const { componentName, pageName, sectionName, libraryName } = ctx;\n  const sources = [componentName ?? '', pageName ?? '', sectionName ?? ''];\n  const statusSources = [...sources, libraryName ?? ''];\n  const normalized = sources.join(' | ').toLowerCase();\n\n  const status = detectStatus(statusSources);\n  const role = detectRole(sources, normalized);\n  const platform = detectPlatform(sources);\n\n  return { role, status, platform };\n}\n\nfunction detectStatus(sources: string[]): ComponentStatus {\n  if (sources.some((value) => value.includes('\u274C'))) {\n    return 'deprecated';\n  }\n\n  if (sources.some((value) => value.includes('\uD83D\uDD04'))) {\n    return 'scheduled';\n  }\n\n  return 'active';\n}\n\nfunction detectRole(\n  sources: string[],\n  normalizedFullName: string,\n): ComponentRole {\n  if (sources.some((value) => value.includes('\uD83D\uDD29'))) {\n    return 'part';\n  }\n\n  return 'main';\n}\n\nfunction detectPlatform(sources: string[]): ComponentPlatform {\n  const normalized = sources.join(' ').toLowerCase();\n\n  if (normalized.includes('[d]')) {\n    return 'desktop';\n  }\n\n  if (normalized.includes('[m]')) {\n    return 'mobile-web';\n  }\n\n  return 'universal';\n}\n", "export function getSectionName(node: BaseNode): string | null {\n  let current: BaseNode | null = node.parent;\n  let topSectionName: string | null = null;\n\n  while (current) {\n    if (current.type === 'SECTION') {\n      topSectionName = current.name;\n    }\n\n    if (current.type === 'PAGE' || current.type === 'DOCUMENT') {\n      break;\n    }\n\n    current = current.parent as BaseNode | null;\n  }\n\n  return topSectionName;\n}\n", "import { DSComponent, DSStructureNode, DSStructureNodePatch, DSVariantStructurePatch } from \"../types\";\nimport { inferCategoryFromName } from \"./utils/inferCategory\";\nimport { collectComponentStructure } from \"./collectStructure\";\nimport { extractVariantList } from \"./variantParser\";\nimport { classifyComponentMeta } from \"../../lib/componentMetaClassifier\";\nimport { getSectionName } from \"./utils/getSectionName\";\n\nexport function describeComponentSet(\n  set: ComponentSetNode,\n  pageName: string,\n  libraryName?: string | null,\n): DSComponent {\n  const normalizedPageName = normalizePageName(pageName);\n  const variants = extractVariantList(set);\n  const defaultVariant = variants.length > 0 ? variants[0].key : undefined;\n\n  const sectionName = getSectionName(set);\n  const classification = classifyComponentMeta({\n    componentName: set.name,\n    pageName,\n    sectionName,\n    libraryName,\n  });\n\n  const collectStructureOptions = { preserveHiddenFills: true };\n\n  let structure: DSComponent['structure'] = [];\n  const variantStructures: Record<string, DSVariantStructurePatch[]> = {};\n\n  // \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C first variant \u043A\u0430\u043A base snapshot, \u0437\u0430\u0442\u0435\u043C \u0445\u0440\u0430\u043D\u0438\u043C per-variant patches.\n  const firstVariant = set.children.find(\n    (child): child is ComponentNode => child.type === \"COMPONENT\",\n  );\n  if (firstVariant) {\n    const firstStructure = collectComponentStructure(\n      firstVariant,\n      collectStructureOptions,\n    );\n    structure = firstStructure;\n    variantStructures[firstVariant.key] = [];\n  }\n\n  for (const child of set.children) {\n    if (child.type !== \"COMPONENT\") continue;\n    if (firstVariant && child.id === firstVariant.id) continue;\n    const variantStructure = collectComponentStructure(\n      child as ComponentNode,\n      collectStructureOptions,\n    );\n    // \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C minimal diff \u043E\u0442 base structure.\n    variantStructures[child.key] = buildVariantOverrides(structure, variantStructure);\n  }\n\n  return {\n    key: set.key,\n    name: set.name,\n    page: normalizedPageName,\n    category: inferCategoryFromName(set.name),\n    description: set.description || \"\",\n    variants,\n    defaultVariant,\n    structure,\n    variantStructures,\n    parentComponent: null,\n    parentComponents: [],\n    role: classification.role,\n    status: classification.status,\n    platform: classification.platform,\n  };\n}\n\nfunction normalizePageName(name: string): string {\n  if (!name) return '';\n  return name.replace(/^[^A-Za-z0-9\u0410-\u042F\u0430-\u044F\u0401\u0451]+/, '').trim();\n}\n\nfunction buildVariantOverrides(\n  base: DSStructureNode[],\n  variant: DSStructureNode[],\n): DSVariantStructurePatch[] {\n  if (base.length === 0) {\n    return variant.map((node) => ({ op: \"add\", node: cloneNode(node) }));\n  }\n\n  const overrides: DSVariantStructurePatch[] = [];\n  const baseMap = new Map<string, DSStructureNode>();\n  const seen = new Set<string>();\n\n  for (const node of base) {\n    baseMap.set(canonicalPath(node.path), node);\n  }\n\n  for (const node of variant) {\n    const key = canonicalPath(node.path);\n    const baseNode = baseMap.get(key);\n    if (!baseNode) {\n      overrides.push({ op: \"add\", node: cloneNode(node) });\n      continue;\n    }\n    seen.add(key);\n    const diff = diffNodes(baseNode, node);\n    if (diff) {\n      overrides.push({ op: \"update\", id: baseNode.id, value: diff });\n    }\n  }\n\n  for (const [key, node] of baseMap.entries()) {\n    if (!seen.has(key)) {\n      overrides.push({ op: \"remove\", id: node.id });\n    }\n  }\n\n  return overrides;\n}\n\nfunction diffNodes(\n  baseNode: DSStructureNode,\n  nextNode: DSStructureNode,\n): DSStructureNodePatch | null {\n  const patch: DSStructureNodePatch = {};\n\n  if (baseNode.type !== nextNode.type) patch.type = nextNode.type;\n  if (baseNode.name !== nextNode.name) patch.name = nextNode.name;\n  if (baseNode.visible !== nextNode.visible) patch.visible = nextNode.visible;\n  if (!isEqual(baseNode.styles, nextNode.styles)) patch.styles = nextNode.styles;\n  if (!isEqual(baseNode.layout, nextNode.layout)) patch.layout = nextNode.layout;\n  if (!isEqual(baseNode.opacity, nextNode.opacity)) patch.opacity = nextNode.opacity;\n  if (!isEqual(baseNode.opacityToken, nextNode.opacityToken)) {\n    patch.opacityToken = nextNode.opacityToken;\n  }\n  if (!isEqual(baseNode.radius, nextNode.radius)) patch.radius = nextNode.radius;\n  if (!isEqual(baseNode.radiusToken, nextNode.radiusToken)) {\n    patch.radiusToken = nextNode.radiusToken;\n  }\n  if (!isEqual(baseNode.effects, nextNode.effects)) patch.effects = nextNode.effects;\n  if (!isEqual(baseNode.fills, nextNode.fills)) patch.fills = nextNode.fills;\n  if (!isEqual(baseNode.fillToken, nextNode.fillToken)) {\n    patch.fillToken = nextNode.fillToken;\n  }\n  if (!isEqual(baseNode.strokes, nextNode.strokes)) patch.strokes = nextNode.strokes;\n  if (!isEqual(baseNode.strokeToken, nextNode.strokeToken)) {\n    patch.strokeToken = nextNode.strokeToken;\n  }\n  if (!isEqual(baseNode.strokeWeight, nextNode.strokeWeight)) {\n    patch.strokeWeight = nextNode.strokeWeight;\n  }\n  if (!isEqual(baseNode.strokeAlign, nextNode.strokeAlign)) {\n    patch.strokeAlign = nextNode.strokeAlign;\n  }\n  if (!isEqual(baseNode.typography, nextNode.typography)) {\n    patch.typography = nextNode.typography;\n  }\n  if (!isEqual(baseNode.typographyToken, nextNode.typographyToken)) {\n    patch.typographyToken = nextNode.typographyToken;\n  }\n  if (!isEqual(baseNode.componentInstance, nextNode.componentInstance)) {\n    patch.componentInstance = nextNode.componentInstance;\n  }\n  if (!isEqual(baseNode.text, nextNode.text)) patch.text = nextNode.text;\n\n  return Object.keys(patch).length ? patch : null;\n}\n\nfunction isEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return a === b;\n  }\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n\nfunction cloneNode(node: DSStructureNode): DSStructureNode {\n  return JSON.parse(JSON.stringify(node));\n}\n\nfunction canonicalPath(path: string): string {\n  if (!path) return '';\n  const segments = path.split(\" / \");\n  if (segments.length === 0) return '';\n  segments[0] = \"@root\";\n  return segments.join(\" / \");\n}\n", "import { DSComponent } from \"../types\";\nimport { inferCategoryFromName } from \"./utils/inferCategory\";\nimport { collectComponentStructure } from \"./collectStructure\";\nimport { classifyComponentMeta } from \"../../lib/componentMetaClassifier\";\nimport { getSectionName } from \"./utils/getSectionName\";\n\nexport function describeSingleComponent(\n  comp: ComponentNode,\n  pageName: string,\n  libraryName?: string | null,\n): DSComponent {\n  const normalizedPageName = normalizePageName(pageName);\n  const sectionName = getSectionName(comp);\n  const classification = classifyComponentMeta({\n    componentName: comp.name,\n    pageName,\n    sectionName,\n    libraryName,\n  });\n  const structure = collectComponentStructure(comp, {\n    preserveHiddenFills: true,\n  });\n\n  return {\n    key: comp.key,\n    name: comp.name,\n    page: normalizedPageName,\n    category: inferCategoryFromName(comp.name),\n    description: comp.description || \"\",\n    variants: [\n      {\n        id: comp.id,\n        key: comp.key,\n        name: comp.name,\n      },\n    ],\n    defaultVariant: comp.key,\n    structure,\n    variantStructures: { [comp.key]: [] },\n    parentComponent: null,\n    parentComponents: [],\n    role: classification.role,\n    status: classification.status,\n    platform: classification.platform,\n  };\n}\n\nfunction normalizePageName(name: string): string {\n  if (!name) return '';\n  return name.replace(/^[^A-Za-z0-9\u0410-\u042F\u0430-\u044F\u0401\u0451]+/, '').trim();\n}\n", "export const DEBUG_MODE = false;\n\nexport function logDebug(topic: string, detail?: unknown) {\n  if (!DEBUG_MODE) return;\n  const entry = {\n    topic,\n    detail,\n    timestamp: new Date().toISOString(),\n  };\n  try {\n    console.log('[Athena::debug]', entry);\n  } catch (error) {\n    console.log('[Athena::debug]', topic, detail);\n  }\n  try {\n    figma.ui.postMessage({ type: 'debug-log', payload: entry });\n  } catch (error) {\n    console.warn('[Athena::debug] failed to forward log to UI', error);\n  }\n}\n", "/// <reference types=\"@figma/plugin-typings\" />\n\nimport {\n  DSComponent,\n  DSExport,\n  DSMeta,\n  DSStructureNode,\n  DSVariantStructurePatch,\n} from '../types';\nimport { describeComponentSet } from './describeComponentSet';\nimport { describeSingleComponent } from './describeSingleComponent';\nimport { resetStructureCache } from './collectStructure';\nimport { logDebug } from '../../debug';\n\nexport function extractComponentsFromDocument(): DSExport {\n  const pages: PageNode[] = [];\n  for (const child of figma.root.children) {\n    if (child.type === 'PAGE') {\n      pages.push(child as PageNode);\n    }\n  }\n\n  const { components, pagesWithComponents, errors } =\n    collectComponentsFromPages(pages);\n  notifyOnErrors(errors);\n\n  const meta: DSMeta = {\n    generatedAt: new Date().toISOString(),\n    version: '0.1.0',\n    files: pagesWithComponents,\n    scope: 'document',\n    fileName: figma.root.name,\n    library: figma.root.name,\n  };\n\n  return {\n    meta,\n    components,\n    tokens: [],\n    typography: [],\n    spacing: [],\n    radius: [],\n  };\n}\n\n// \uD83D\uDD39 \u041D\u043E\u0432\u044B\u0439 \u044D\u043A\u0441\u043F\u043E\u0440\u0442 \u2014 \u0442\u043E\u043B\u044C\u043A\u043E \u043F\u043E \u0442\u0435\u043A\u0443\u0449\u0435\u0439 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435\nexport function extractComponentsFromCurrentPage(): DSExport {\n  const current = figma.currentPage; // \u0432\u0441\u0435\u0433\u0434\u0430 PageNode\n  const { components, errors, pageHasComponents } =\n    collectComponentsFromPage(current);\n  notifyOnErrors(errors);\n\n  const meta: DSMeta = {\n    generatedAt: new Date().toISOString(),\n    version: '0.1.0',\n    files: pageHasComponents ? [normalizePageName(current.name)] : [],\n    scope: 'current-page',\n    fileName: figma.root.name,\n    library: figma.root.name,\n  };\n\n  return {\n    meta,\n    components,\n    tokens: [],\n    typography: [],\n    spacing: [],\n    radius: [],\n  };\n}\n\nfunction buildErrorMessage(\n  pageName: string,\n  nodeName: string,\n  error: unknown,\n): string {\n  const reason =\n    error instanceof Error ? error.message : 'unknown component error';\n  return `[Athena] \u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430 \"${nodeName}\" (\u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430 \"${pageName}\"): ${reason}`;\n}\n\nfunction notifyOnErrors(errors: string[]) {\n  if (errors.length === 0) return;\n  const first = errors[0];\n  console.warn('[Athena] component parsing errors:', errors);\n  figma.notify(\n    `\u041D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u044B \u043D\u0435 \u0432\u044B\u0433\u0440\u0443\u0436\u0435\u043D\u044B (${errors.length}). \u0421\u043C. \u043A\u043E\u043D\u0441\u043E\u043B\u044C.`,\n    { timeout: 5000 },\n  );\n}\n\nexport function collectComponentsFromPage(\n  page: PageNode,\n): {\n  components: DSComponent[];\n  errors: string[];\n  pageHasComponents: boolean;\n} {\n  resetStructureCache();\n  logDebug('collect-page-start', { page: page.name });\n  const result = collectComponentsFromPageInternal(page);\n  assignDepthMetrics(result.components);\n  logDebug('collect-page-finish', {\n    page: page.name,\n    components: result.components.length,\n    errors: result.errors.length,\n  });\n  return result;\n}\n\nfunction collectComponentsFromPages(pages: PageNode[]): {\n  components: DSComponent[];\n  pagesWithComponents: string[];\n  errors: string[];\n} {\n  resetStructureCache();\n  logDebug('collect-pages-start', {\n    pageNames: pages.map((p) => p.name),\n  });\n  const components: DSComponent[] = [];\n  const pagesWithComponents = new Set<string>();\n  const errors: string[] = [];\n\n  for (const page of pages) {\n    const pageResult = collectComponentsFromPageInternal(page);\n    components.push(...pageResult.components);\n    errors.push(...pageResult.errors);\n    if (pageResult.pageHasComponents) {\n      pagesWithComponents.add(normalizePageName(page.name));\n    }\n  }\n\n  logDebug('collect-pages-finish', {\n    totalComponents: components.length,\n    totalPagesWithComponents: pagesWithComponents.size,\n  });\n\n  assignDepthMetrics(components);\n\n  return {\n    components,\n    pagesWithComponents: Array.from(pagesWithComponents),\n    errors,\n  };\n}\n\nexport function assignDepthMetrics(components: DSComponent[]) {\n  // \u041F\u0440\u043E\u0445\u043E\u0434\u0438\u043C component structures, \u0447\u0442\u043E\u0431\u044B \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0438\u0442\u044C nesting depth parts \u0432\u043D\u0443\u0442\u0440\u0438 mains.\n  const componentsByKey = new Map<string, DSComponent>();\n  for (const component of components) {\n    if (component.key) {\n      componentsByKey.set(component.key, component);\n    }\n    for (const variant of component.variants ?? []) {\n      if (variant.key) {\n        componentsByKey.set(variant.key, component);\n      }\n    }\n  }\n\n  for (const component of components) {\n    const structures = buildStructureSets(component);\n    for (const nodes of structures) {\n      processDepthNodes(nodes, component, componentsByKey);\n    }\n  }\n}\n\nfunction buildStructureSets(host: DSComponent): DSStructureNode[][] {\n  const structures: DSStructureNode[][] = [];\n  if (host.structure && host.structure.length > 0) {\n    structures.push(host.structure);\n  }\n  if (host.variantStructures) {\n    for (const patches of Object.values(host.variantStructures)) {\n      const variantNodes = buildStructureFromPatches(host.structure ?? [], patches);\n      if (variantNodes.length > 0) {\n        structures.push(variantNodes);\n      }\n    }\n  }\n  return structures;\n}\n\nfunction processDepthNodes(\n  nodes: DSStructureNode[],\n  host: DSComponent,\n  componentsByKey: Map<string, DSComponent>,\n) {\n  if (!nodes.length) return;\n  const childrenMap = new Map<number | null, DSStructureNode[]>();\n  for (const node of nodes) {\n    const parentId = node.parentId ?? null;\n    if (!childrenMap.has(parentId)) {\n      childrenMap.set(parentId, []);\n    }\n    childrenMap.get(parentId)!.push(node);\n  }\n\n    const traverse = (node: DSStructureNode, depth: number) => {\n      const childKey = node.componentInstance?.componentKey;\n      if (childKey) {\n        const target = componentsByKey.get(childKey);\n        if (target && target.role === 'part') {\n          target.depthInside ??= [];\n          if (!target.depthInside.includes(depth)) {\n            target.depthInside.push(depth);\n          }\n          if (typeof target.depthActual !== 'number') {\n            target.depthActual = depth;\n          } else {\n            target.depthActual = Math.min(target.depthActual, depth);\n          }\n          if (host.role === 'main') {\n            host.depthInside ??= [];\n            if (!host.depthInside.includes(depth)) {\n              host.depthInside.push(depth);\n            }\n            if (host.depth === undefined || depth > host.depth) {\n              host.depth = depth;\n            }\n          }\n        }\n      }\n\n    const children = childrenMap.get(node.id ?? null) ?? [];\n    for (const child of children) {\n      traverse(child, depth + 1);\n    }\n  };\n\n  const rootNodes = childrenMap.get(null) ?? [];\n  for (const root of rootNodes) {\n    traverse(root, 0);\n  }\n}\n\nfunction collectComponentsFromPageInternal(page: PageNode): {\n  components: DSComponent[];\n  errors: string[];\n  pageHasComponents: boolean;\n} {\n  // Depth-first traversal: \u0441\u043E\u0431\u0438\u0440\u0430\u0435\u043C component sets \u0438 standalone components.\n  const components: DSComponent[] = [];\n  const errors: string[] = [];\n  let pageHasComponents = false;\n  const stack: SceneNode[] = [...(page.children as SceneNode[])];\n\n  while (stack.length > 0) {\n    const node = stack.pop()!;\n\n    if (node.type === 'COMPONENT_SET') {\n      logDebug('component-set-detected', {\n        page: page.name,\n        name: node.name,\n        id: node.id,\n      });\n      try {\n        components.push(\n          describeComponentSet(node, normalizePageName(page.name), figma.root.name),\n        );\n      } catch (error) {\n        const message = buildErrorMessage(page.name, node.name, error);\n        console.error(message, error);\n        errors.push(message);\n      }\n      pageHasComponents = true;\n      continue;\n    }\n\n    if (node.type === 'COMPONENT') {\n      logDebug('component-detected', {\n        page: page.name,\n        name: node.name,\n        id: node.id,\n      });\n      if (!node.parent || node.parent.type !== 'COMPONENT_SET') {\n        try {\n          components.push(\n            describeSingleComponent(node, normalizePageName(page.name), figma.root.name),\n          );\n        } catch (error) {\n          const message = buildErrorMessage(page.name, node.name, error);\n          console.error(message, error);\n          errors.push(message);\n        }\n        pageHasComponents = true;\n      }\n      continue;\n    }\n\n    if (node.type === 'INSTANCE') {\n      logDebug('instance-skipped', {\n        page: page.name,\n        name: node.name,\n        id: node.id,\n      });\n      continue;\n    }\n\n    if ('children' in node) {\n      stack.push(...((node.children as SceneNode[]) ?? []));\n    }\n  }\n\n  logDebug('collect-page-internal-finish', {\n    page: page.name,\n    components: components.length,\n    errors: errors.length,\n  });\n\n  return { components, errors, pageHasComponents };\n}\n\nexport async function collectComponentsFromPageChunked(\n  page: PageNode,\n  token: { aborted: boolean } | null,\n  onProgress?: (processedNodes: number) => void,\n): Promise<{\n  components: DSComponent[];\n  errors: string[];\n  pageHasComponents: boolean;\n  aborted: boolean;\n}> {\n  // Chunked traversal \u043E\u0442\u0434\u0430\u0451\u0442 \u0443\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 event loop, \u0447\u0442\u043E\u0431\u044B \u0434\u0435\u0440\u0436\u0430\u0442\u044C Figma responsive.\n  const components: DSComponent[] = [];\n  const errors: string[] = [];\n  let pageHasComponents = false;\n  const stack: SceneNode[] = [...(page.children as SceneNode[])];\n  let processedNodes = 0;\n  const chunkSize = 250;\n\n  while (stack.length > 0) {\n    if (token?.aborted) {\n      return { components, errors, pageHasComponents, aborted: true };\n    }\n    const node = stack.pop()!;\n\n    if (node.type === 'COMPONENT_SET') {\n      logDebug('component-set-detected', {\n        page: page.name,\n        name: node.name,\n        id: node.id,\n      });\n      try {\n      components.push(\n        describeComponentSet(node, normalizePageName(page.name), figma.root.name),\n      );\n      } catch (error) {\n        const message = buildErrorMessage(page.name, node.name, error);\n        console.error(message, error);\n        errors.push(message);\n      }\n      pageHasComponents = true;\n      continue;\n    }\n\n    if (node.type === 'COMPONENT') {\n      logDebug('component-detected', {\n        page: page.name,\n        name: node.name,\n        id: node.id,\n      });\n      if (!node.parent || node.parent.type !== 'COMPONENT_SET') {\n        try {\n          components.push(\n            describeSingleComponent(node, normalizePageName(page.name), figma.root.name),\n          );\n        } catch (error) {\n          const message = buildErrorMessage(page.name, node.name, error);\n          console.error(message, error);\n          errors.push(message);\n        }\n        pageHasComponents = true;\n      }\n      continue;\n    }\n\n    if (node.type === 'INSTANCE') {\n      logDebug('instance-skipped', {\n        page: page.name,\n        name: node.name,\n        id: node.id,\n      });\n      continue;\n    }\n\n    if ('children' in node) {\n      stack.push(...((node.children as SceneNode[]) ?? []));\n    }\n\n    processedNodes += 1;\n    if (processedNodes % chunkSize === 0) {\n      onProgress?.(processedNodes);\n      await new Promise((resolve) => setTimeout(resolve, 0));\n    }\n  }\n\n  onProgress?.(processedNodes);\n  logDebug('collect-page-internal-finish', {\n    page: page.name,\n    components: components.length,\n    errors: errors.length,\n  });\n\n  return {\n    components,\n    errors,\n    pageHasComponents,\n    aborted: Boolean(token?.aborted),\n  };\n}\n\nfunction normalizePageName(name: string): string {\n  if (!name) return '';\n  return name.replace(/^[^A-Za-z0-9\u0410-\u042F\u0430-\u044F\u0401\u0451]+/, '').trim();\n}\n\nfunction buildStructureFromPatches(\n  base: DSStructureNode[],\n  patches: DSVariantStructurePatch[] | undefined,\n): DSStructureNode[] {\n  const nodes = base.map(cloneNode);\n  const nodeMap = new Map<number, DSStructureNode>();\n  for (const node of nodes) {\n    nodeMap.set(node.id, node);\n  }\n\n  if (!patches || patches.length === 0) {\n    return nodes;\n  }\n\n  for (const patch of patches) {\n    switch (patch.op) {\n      case 'update': {\n        const target = nodeMap.get(patch.id);\n        if (target) {\n          Object.assign(target, patch.value);\n        }\n        break;\n      }\n      case 'remove': {\n        nodeMap.delete(patch.id);\n        const index = nodes.findIndex((node) => node.id === patch.id);\n        if (index !== -1) {\n          nodes.splice(index, 1);\n        }\n        break;\n      }\n      case 'add': {\n        const copy = cloneNode(patch.node);\n        nodes.push(copy);\n        nodeMap.set(copy.id, copy);\n        break;\n      }\n    }\n  }\n\n  return nodes;\n}\n\nfunction cloneNode(node: DSStructureNode): DSStructureNode {\n  return JSON.parse(JSON.stringify(node));\n}\n", "/// <reference types=\"@figma/plugin-typings\" />\n\nimport {\n  extractComponentsFromDocument,\n  extractComponentsFromCurrentPage,\n  collectComponentsFromPage,\n  collectComponentsFromPageChunked,\n} from './engine';\nimport type {\n  DSComponent,\n  DSExport,\n  DSStructureNode,\n  DSStructureNodePatch,\n  DSVariantStructurePatch,\n} from './engine';\nimport { logDebug } from './debug';\n\ntype SerializedVariableValue =\n  | boolean\n  | string\n  | number\n  | RGB\n  | RGBA\n  | VariableAlias;\n\ninterface TokenExportMeta {\n  generatedAt: string;\n  fileName: string;\n  library: string;\n}\n\ninterface TokenVariableExport {\n  id: string;\n  name: string;\n  description: string;\n  hiddenFromPublishing: boolean;\n  remote: boolean;\n  key: string;\n  resolvedType: VariableResolvedDataType;\n  variableCollectionId: string;\n  scopes: VariableScope[];\n  codeSyntax: Record<CodeSyntaxPlatform, string | undefined>;\n  valuesByMode: Record<string, SerializedVariableValue | undefined>;\n  hexByMode: Record<string, string | undefined>;\n  collectionName: string;\n  groupName: string;\n  tokenName: string;\n}\n\ninterface TokenCollectionExport {\n  id: string;\n  name: string;\n  key: string;\n  defaultModeId: string;\n  hiddenFromPublishing: boolean;\n  remote: boolean;\n  modes: Array<{ modeId: string; name: string }>;\n  variables: TokenVariableExport[];\n}\n\ninterface TokenExportPayload {\n  meta: TokenExportMeta;\n  collections: TokenCollectionExport[];\n}\n\ninterface StyleEntry {\n  key: string;\n  name: string;\n  group: string;\n  type: string;\n  value: StyleValue;\n}\n\ntype StyleValue =\n  | { kind: 'effect'; data: Effect }\n  | {\n      kind: 'text';\n      data: {\n        fontName: string | null;\n        fontSize: number | null;\n        lineHeight: string | null;\n        letterSpacing: string | null;\n      };\n    }\n  | {\n      kind: 'paint';\n      data: {\n        paints: Array<{\n          type: string;\n          color?: string;\n          opacity?: number;\n        }>;\n      };\n    };\n\ninterface StyleExportPayload {\n  meta: TokenExportMeta;\n  styles: StyleEntry[];\n}\n\nconst blueTintTokensUrl =\n  'https://ackedze.github.io/nemesis/JSONS/BlueTint Base Colors -- BlueTint Base Colors.json';\n// Remote token library \u0434\u043B\u044F resolve VARIABLE_ALIAS \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0439 \u0432 \u0440\u0435\u0430\u043B\u044C\u043D\u044B\u0435 \u0446\u0432\u0435\u0442\u0430.\nlet blueTintVariableMap: Map<string, TokenVariableExport> | null = null;\nlet blueTintLoadPromise: Promise<void> | null = null;\n\nconsole.log('[CODE] plugin loaded');\nlogDebug('plugin-loaded');\n\nfigma.showUI(__html__, { width: 1280, height: 720 });\nconsole.log('[CODE] UI shown');\nlogDebug('ui-shown', { width: 1280, height: 720 });\n\n// \u0420\u043E\u0443\u0442\u0438\u043C UI events \u043D\u0430 export/collect actions.\nfigma.ui.onmessage = (msg) => {\n  console.log('[CODE] received message from UI:', msg);\n  logDebug('ui-message', msg);\n\n  if (msg.type === 'test') {\n    console.log('[CODE] test message received, sending echo');\n    figma.ui.postMessage({\n      type: 'echo',\n      payload: { received: msg },\n    });\n    return;\n  }\n\n  if (msg.type === 'export-components') {\n    console.log('[CODE] starting paged export for document');\n    logDebug('export-components-request');\n    cancelPagedExport();\n    startPagedExportFromDocument();\n    return;\n  }\n\n  if (msg.type === 'export-components-current-page') {\n    console.log('[CODE] starting paged export from current page');\n    logDebug('export-current-page-request');\n    cancelPagedExport();\n    startPagedExportFromCurrentPage();\n    return;\n  }\n\n  if (msg.type === 'export-components-continue') {\n    console.log('[CODE] continuing paged export');\n    logDebug('export-components-continue-request');\n    continuePagedExport();\n    return;\n  }\n\n  if (msg.type === 'cancel-export') {\n    console.log('[CODE] cancel paged export');\n    cancelPagedExport();\n    return;\n  }\n\n  if (msg.type === 'collect-tokens') {\n    console.log('[CODE] collecting tokens');\n    logDebug('collect-tokens-request');\n    collectTokensAndSend();\n    return;\n  }\n  if (msg.type === 'collect-styles') {\n    console.log('[CODE] collecting styles');\n    logDebug('collect-styles-request');\n    collectStylesAndSend();\n    return;\n  }\n};\n\nfunction sendExportResult(scope: string, data: DSExport) {\n  const sanitized = sanitizeExportPayload(data);\n  const json = JSON.stringify(sanitized, null, 2);\n  console.log(`[CODE] sending export-result (${scope}). length =`, json.length);\n  logDebug('send-export', {\n    scope,\n    components: data.components.length,\n    meta: data.meta,\n  });\n  figma.ui.postMessage({\n    type: 'export-result',\n    payload: { json, data: sanitized, mode: 'full' },\n  });\n}\n\ninterface ExportSession {\n  id: number;\n  totalPages: number;\n  pendingPages: PageNode[];\n  processedPages: number;\n  components: DSComponent[];\n  errors: string[];\n  autoContinue: boolean;\n  scope: 'current-page' | 'document';\n}\n\nlet pagedSession: ExportSession | null = null;\nlet sessionCounter = 0;\nlet exportCancelToken: { aborted: boolean } | null = null;\nfunction startPagedExportFromCurrentPage() {\n  const pages = getPagesStartingFromCurrentPage();\n  if (pages.length === 0) {\n    const data = extractComponentsFromCurrentPage();\n    sendExportResult('CURRENT PAGE', data);\n    return;\n  }\n\n  startPagedExport(pages, false, 'current-page');\n}\n\nfunction startPagedExportFromDocument() {\n  const pages = getAllPages();\n  if (pages.length === 0) {\n    const data = extractComponentsFromDocument();\n    sendExportResult('ALL', data);\n    return;\n  }\n\n  startPagedExport(pages, true, 'document');\n}\n\nfunction startPagedExport(\n  pages: PageNode[],\n  autoContinue: boolean,\n  scope: 'current-page' | 'document',\n) {\n  // Page-by-page export \u0434\u0435\u0440\u0436\u0438\u0442 UI responsive \u043D\u0430 \u0431\u043E\u043B\u044C\u0448\u0438\u0445 \u0444\u0430\u0439\u043B\u0430\u0445.\n  sessionCounter += 1;\n  pagedSession = {\n    id: sessionCounter,\n    totalPages: pages.length,\n    pendingPages: [...pages],\n    processedPages: 0,\n    components: [],\n    errors: [],\n    autoContinue,\n    scope,\n  };\n  exportCancelToken = { aborted: false };\n\n  logDebug('paged-export-start', {\n    sessionId: sessionCounter,\n    totalPages: pages.length,\n    autoContinue,\n    scope,\n  });\n\n  void processNextPage();\n}\n\nfunction getPagesStartingFromCurrentPage(): PageNode[] {\n  const pages: PageNode[] = [];\n  for (const child of figma.root.children) {\n    if (child.type === 'PAGE') {\n      pages.push(child as PageNode);\n    }\n  }\n  if (pages.length === 0) return [];\n  const current = figma.currentPage;\n  const index = pages.findIndex((page) => page.id === current.id);\n  if (index <= 0) return pages;\n  return pages.slice(index).concat(pages.slice(0, index));\n}\n\nfunction getAllPages(): PageNode[] {\n  const pages: PageNode[] = [];\n  for (const child of figma.root.children) {\n    if (child.type === 'PAGE') {\n      pages.push(child as PageNode);\n    }\n  }\n  return pages;\n}\n\nfunction cancelPagedExport() {\n  if (exportCancelToken) {\n    exportCancelToken.aborted = true;\n    exportCancelToken = null;\n  }\n  pagedSession = null;\n  figma.ui.postMessage({ type: 'export-cancelled' });\n}\n\nfunction continuePagedExport() {\n  if (!pagedSession) return;\n  void processNextPage();\n}\n\nasync function processNextPage() {\n  if (!pagedSession) return;\n  const session = pagedSession;\n  if (session.pendingPages.length === 0) {\n    finalizePagedExport();\n    return;\n  }\n\n  const page = session.pendingPages.shift()!;\n  console.log(\n    '[CODE] processing page',\n    page.name,\n    'processed',\n    session.processedPages,\n  );\n  logDebug('paged-page-start', {\n    page: page.name,\n    remaining: session.pendingPages.length,\n    processed: session.processedPages,\n  });\n  const { components, errors, pageHasComponents, aborted } =\n    await collectComponentsFromPageChunked(\n      page,\n      exportCancelToken,\n      (processedNodes) => {\n        figma.ui.postMessage({\n          type: 'export-progress',\n          payload: {\n            sessionId: session.id,\n            pageName: normalizePageName(page.name),\n            processedNodes,\n            completedPages: session.processedPages,\n            totalPages: session.totalPages,\n          },\n        });\n      },\n    );\n  if (aborted) {\n    console.log('[CODE] paged export aborted');\n    finalizePagedExport();\n    return;\n  }\n  logDebug('paged-page-result', {\n    page: page.name,\n    components: components.length,\n    errors: errors.length,\n  });\n  session.components.push(...components);\n  session.errors.push(...errors);\n\n  session.processedPages += 1;\n\n  const normalizedPageName = normalizePageName(page.name);\n  const pageExport = buildPageExport(page, components, pageHasComponents);\n  const hasMore = session.pendingPages.length > 0;\n  sendPagedProgress(pageExport, hasMore, normalizedPageName);\n\n  if (!hasMore) {\n    finalizePagedExport();\n    return;\n  }\n\n  if (session.autoContinue) {\n    setTimeout(() => {\n      void processNextPage();\n    }, 0);\n  }\n}\n\nfunction buildPageExport(\n  page: PageNode,\n  components: DSComponent[],\n  pageHasComponents: boolean,\n): DSExport {\n  const normalizedPageName = normalizePageName(page.name);\n  return {\n    meta: {\n      generatedAt: new Date().toISOString(),\n      version: '0.1.0',\n      files: pageHasComponents ? [normalizedPageName] : [],\n      scope: 'current-page',\n      fileName: figma.root.name,\n      library: figma.root.name,\n    },\n    components,\n    tokens: [],\n    typography: [],\n    spacing: [],\n    radius: [],\n  };\n}\n\nfunction sendPagedProgress(\n  pageExport: DSExport,\n  hasMore: boolean,\n  currentPage: string,\n) {\n  if (!pagedSession) return;\n  const session = pagedSession;\n  const sanitized = sanitizeExportPayload(pageExport);\n  const json = JSON.stringify(sanitized, null, 2);\n  figma.ui.postMessage({\n    type: 'export-result',\n    payload: {\n      json,\n      data: sanitized,\n      mode: 'paged',\n      pageName: normalizePageName(currentPage),\n      progress: {\n        completed: session.processedPages,\n        total: session.totalPages,\n        hasMore,\n        autoContinue: session.autoContinue,\n        currentPage,\n      },\n    },\n  });\n}\n\nfunction finalizePagedExport() {\n  if (!pagedSession) return;\n  notifyPagedErrors(pagedSession.errors);\n  logDebug('paged-export-finished', {\n    processedPages: pagedSession.processedPages,\n    errors: pagedSession.errors.length,\n  });\n  pagedSession = null;\n}\n\nfunction notifyPagedErrors(errors: string[]) {\n  if (errors.length === 0) return;\n  console.warn('[Athena] component parsing errors:', errors);\n  figma.notify(\n    `\u041D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u044B \u043D\u0435 \u0432\u044B\u0433\u0440\u0443\u0436\u0435\u043D\u044B (${errors.length}). \u0421\u043C. \u043A\u043E\u043D\u0441\u043E\u043B\u044C.`,\n    { timeout: 5000 },\n  );\n}\n\nasync function collectTokensAndSend() {\n  try {\n    const payload = await collectTokensFromFile();\n    const json = JSON.stringify(payload, null, 2);\n    logDebug('collect-tokens-result', {\n      collections: payload.collections.length,\n    });\n    figma.ui.postMessage({\n      type: 'collect-tokens-result',\n      payload: { json, data: payload },\n    });\n  } catch (error) {\n    const message =\n      error instanceof Error ? error.message : '\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430';\n    console.error('[CODE] failed to collect tokens', error);\n    logDebug('collect-tokens-error', { error: message });\n    figma.notify(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043E\u0431\u0440\u0430\u0442\u044C \u0442\u043E\u043A\u0435\u043D\u044B: ${message}`, { timeout: 5000 });\n  }\n}\n\nfunction collectStylesAndSend() {\n  try {\n    const payload = collectStylesFromDocument();\n    const json = JSON.stringify(payload, null, 2);\n    logDebug('collect-styles-result', {\n      styles: payload.styles.length,\n    });\n    figma.ui.postMessage({\n      type: 'collect-styles-result',\n      payload: { json, data: payload },\n    });\n  } catch (error) {\n    const message =\n      error instanceof Error ? error.message : '\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430';\n    console.error('[CODE] failed to collect styles', error);\n    logDebug('collect-styles-error', { error: message });\n    figma.notify(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043E\u0431\u0440\u0430\u0442\u044C \u0441\u0442\u0438\u043B\u0438: ${message}`, { timeout: 5000 });\n  }\n}\n\nasync function collectTokensFromFile(): Promise<TokenExportPayload> {\n  // Variables API export \u0441 hex map \u0438 alias resolution.\n  if (!figma.variables) {\n    throw new Error('Variables API not \u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D \u0432 \u044D\u0442\u043E\u043C \u0444\u0430\u0439\u043B\u0435');\n  }\n\n  const [collections, variables] = await Promise.all([\n    figma.variables.getLocalVariableCollectionsAsync(),\n    figma.variables.getLocalVariablesAsync(),\n  ]);\n\n  const variableById = new Map<string, Variable>();\n  variables.forEach((variable) => {\n    variableById.set(variable.id, variable);\n  });\n\n  await ensureBlueTintVariablesLoaded();\n\n  const collectionExports: TokenCollectionExport[] = collections.map(\n    (collection) => {\n      const collectionVariables = collection.variableIds\n        .map((id) => variableById.get(id))\n        .filter((variable): variable is Variable => Boolean(variable));\n\n      const modes = Array.isArray(collection.modes) ? collection.modes : [];\n\n      return {\n        id: collection.id,\n        name: collection.name,\n        key: collection.key,\n        defaultModeId: collection.defaultModeId,\n        hiddenFromPublishing: collection.hiddenFromPublishing,\n        remote: collection.remote,\n        modes: modes.map((mode) => ({\n          modeId: mode.modeId,\n          name: mode.name,\n        })),\n        variables: collectionVariables.map((variable) =>\n          serializeVariable(variable, collection.name || collection.key),\n        ),\n      };\n    },\n  );\n\n  return {\n    meta: {\n      generatedAt: new Date().toISOString(),\n      fileName: figma.root.name,\n      library: figma.root.name,\n    },\n    collections: collectionExports,\n  };\n}\n\nfunction collectStylesFromDocument(): StyleExportPayload {\n  const effectStyles = figma.getLocalEffectStyles();\n  const textStyles = figma.getLocalTextStyles();\n  const paintStyles = figma.getLocalPaintStyles();\n  const entries: StyleEntry[] = [];\n  for (const style of effectStyles) {\n    const nameParts = splitVariableName(style.name);\n    const group = nameParts.groupName;\n    const baseName = nameParts.tokenName || style.name;\n    const effects = Array.isArray(style.effects) ? style.effects : [];\n    for (const effect of effects) {\n      entries.push({\n        key: style.key,\n        name: baseName,\n        group,\n        type: formatEffectType(effect.type),\n        value: { kind: 'effect', data: effect },\n      });\n    }\n  }\n\n  for (const style of textStyles) {\n    const nameParts = splitVariableName(style.name);\n    const group = nameParts.groupName;\n    const baseName = nameParts.tokenName || style.name;\n    entries.push({\n      key: style.key,\n      name: baseName,\n      group,\n      type: 'text',\n      value: { kind: 'text', data: describeTextStyle(style) },\n    });\n  }\n\n  for (const style of paintStyles) {\n    const nameParts = splitVariableName(style.name);\n    const group = nameParts.groupName;\n    const baseName = nameParts.tokenName || style.name;\n    entries.push({\n      key: style.key,\n      name: baseName,\n      group,\n      type: 'paint',\n      value: { kind: 'paint', data: describePaintStyle(style) },\n    });\n  }\n\n  return {\n    meta: {\n      generatedAt: new Date().toISOString(),\n      fileName: figma.root.name,\n      library: figma.root.name,\n    },\n    styles: entries,\n  };\n}\n\nfunction formatEffectType(type: Effect['type']): string {\n  return type.toLowerCase().replace('_', ' ');\n}\n\nfunction describeEffectValue(effect: Effect): string {\n  const parts: string[] = [];\n  if (effect.offset) {\n    parts.push(\n      'offset: ' +\n        formatNumber(effect.offset.x) +\n        ', ' +\n        formatNumber(effect.offset.y),\n    );\n  }\n  if (typeof effect.radius === 'number') {\n    parts.push('radius: ' + formatNumber(effect.radius));\n  }\n  if (typeof effect.spread === 'number') {\n    parts.push('spread: ' + formatNumber(effect.spread));\n  }\n  if (effect.color) {\n    parts.push('color: ' + colorToString(effect.color));\n  }\n  return parts.length ? parts.join(' \u2022 ') : '\u2014';\n}\n\nfunction describeTextStyle(style: TextStyle): {\n  fontName: string | null;\n  fontSize: number | null;\n  lineHeight: string | null;\n  letterSpacing: string | null;\n} {\n  const fontName = style.fontName;\n  const fontLabel =\n    fontName && fontName !== figma.mixed\n      ? `${fontName.family} ${fontName.style}`.trim()\n      : '\u2014';\n  const fontSize =\n    style.fontSize !== figma.mixed && typeof style.fontSize === 'number'\n      ? style.fontSize\n      : null;\n  const lineHeight =\n    style.lineHeight !== figma.mixed && style.lineHeight\n      ? formatLineHeight(style.lineHeight)\n      : null;\n  const letterSpacing =\n    style.letterSpacing !== figma.mixed && style.letterSpacing\n      ? formatLetterSpacing(style.letterSpacing)\n      : null;\n  return {\n    fontName: fontLabel === '\u2014' ? null : fontLabel,\n    fontSize,\n    lineHeight,\n    letterSpacing,\n  };\n}\n\nfunction describePaintStyle(style: PaintStyle): {\n  paints: Array<{ type: string; color?: string; opacity?: number }>;\n} {\n  const paints = Array.isArray(style.paints) ? style.paints : [];\n  return {\n    paints: paints.map(serializePaintValue).filter(Boolean),\n  };\n}\n\nfunction serializePaintValue(\n  paint: Paint,\n): { type: string; color?: string; opacity?: number } | null {\n  if (!paint) return null;\n  if (paint.type === 'SOLID') {\n    const color = colorToString(paint.color);\n    const opacity =\n      typeof paint.opacity === 'number' ? paint.opacity : undefined;\n    return {\n      type: 'solid',\n      color,\n      opacity,\n    };\n  }\n  return {\n    type: paint.type.toLowerCase().replace('_', ' '),\n  };\n}\n\nfunction formatLineHeight(lineHeight: LineHeight): string {\n  if (lineHeight.unit === 'AUTO') return 'auto';\n  if (lineHeight.unit === 'PIXELS') return formatNumber(lineHeight.value);\n  if (lineHeight.unit === 'PERCENT') return formatNumber(lineHeight.value) + '%';\n  return String(lineHeight.value);\n}\n\nfunction formatLetterSpacing(letterSpacing: LetterSpacing): string {\n  if (letterSpacing.unit === 'PIXELS') return formatNumber(letterSpacing.value);\n  if (letterSpacing.unit === 'PERCENT') return formatNumber(letterSpacing.value) + '%';\n  return String(letterSpacing.value);\n}\n\nfunction formatNumber(value: number): string {\n  return Number.isFinite(value) ? value.toFixed(2) : String(value);\n}\n\nfunction colorToString(color: RGB | RGBA): string {\n  const r = clampColorComponent(color.r);\n  const g = clampColorComponent(color.g);\n  const b = clampColorComponent(color.b);\n  const alpha =\n    typeof color.a === 'number' ? color.a : typeof color.alpha === 'number'\n      ? color.alpha\n      : 1;\n  const rgba = `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(2)})`;\n  return '#' + toHex(r) + toHex(g) + toHex(b) + ' / ' + rgba;\n}\n\nfunction splitVariableName(rawName?: string | null) {\n  if (!rawName) {\n    return { groupName: '\u0411\u0435\u0437 \u0433\u0440\u0443\u043F\u043F\u044B', tokenName: '\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F' };\n  }\n  const trimmed = rawName.trim();\n  if (!trimmed) {\n    return { groupName: '\u0411\u0435\u0437 \u0433\u0440\u0443\u043F\u043F\u044B', tokenName: '\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F' };\n  }\n  const parts = trimmed.split('/');\n  if (parts.length <= 1) {\n    return { groupName: '\u0411\u0435\u0437 \u0433\u0440\u0443\u043F\u043F\u044B', tokenName: trimmed };\n  }\n  return {\n    groupName: parts[0] || '\u0411\u0435\u0437 \u0433\u0440\u0443\u043F\u043F\u044B',\n    tokenName: parts.slice(1).join('/') || '\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F',\n  };\n}\n\nfunction serializeVariable(\n  variable: Variable,\n  collectionName?: string | null,\n): TokenVariableExport {\n  const rawName = variable.name || variable.key;\n  const nameParts = splitVariableName(rawName);\n  const originalValues = copyValuesByMode(variable.valuesByMode);\n  const resolvedValues = resolveAliasValues(originalValues);\n  return {\n    id: variable.id,\n    name: variable.name,\n    description: variable.description,\n    hiddenFromPublishing: variable.hiddenFromPublishing,\n    remote: variable.remote,\n    key: variable.key,\n    resolvedType: variable.resolvedType,\n    variableCollectionId: variable.variableCollectionId,\n    scopes: Array.isArray(variable.scopes) ? variable.scopes.slice() : [],\n    codeSyntax: copyCodeSyntax(variable.codeSyntax),\n    valuesByMode: resolvedValues,\n    hexByMode: buildHexMap(resolvedValues),\n    collectionName: collectionName || '\u0411\u0435\u0437 \u043A\u043E\u043B\u043B\u0435\u043A\u0446\u0438\u0438',\n    groupName: nameParts.groupName,\n    tokenName: nameParts.tokenName,\n  };\n}\n\nfunction copyCodeSyntax(\n  codeSyntax?: Record<CodeSyntaxPlatform, string | undefined>,\n): Record<CodeSyntaxPlatform, string | undefined> {\n  const platforms: CodeSyntaxPlatform[] = ['WEB', 'ANDROID', 'iOS'];\n  const result: Record<CodeSyntaxPlatform, string | undefined> = {\n    WEB: undefined,\n    ANDROID: undefined,\n    iOS: undefined,\n  };\n  platforms.forEach((platform) => {\n    if (codeSyntax && codeSyntax[platform]) {\n      result[platform] = codeSyntax[platform];\n    }\n  });\n  return result;\n}\n\nfunction copyValuesByMode(\n  values: Record<string, SerializedVariableValue> | undefined,\n): Record<string, SerializedVariableValue | undefined> {\n  const result: Record<string, SerializedVariableValue | undefined> = {};\n  if (!values) return result;\n  for (const key in values) {\n    if (Object.prototype.hasOwnProperty.call(values, key)) {\n      result[key] = values[key];\n    }\n  }\n  return result;\n}\n\nfunction buildHexMap(\n  values: Record<string, SerializedVariableValue> | undefined,\n): Record<string, string | undefined> {\n  const result: Record<string, string | undefined> = {};\n  if (!values) return result;\n  for (const modeId in values) {\n    if (!Object.prototype.hasOwnProperty.call(values, modeId)) continue;\n    const hex = convertValueToHex(values[modeId]);\n    result[modeId] = hex;\n  }\n  return result;\n}\n\nfunction convertValueToHex(value: SerializedVariableValue | undefined): string | undefined {\n  if (!value || typeof value !== 'object') return undefined;\n  const color = value as RGB | RGBA;\n  const hasRgb =\n    typeof (color as RGB).r === 'number' &&\n    typeof (color as RGB).g === 'number' &&\n    typeof (color as RGB).b === 'number';\n  if (!hasRgb) return undefined;\n  const r = clampColorComponent(color.r);\n  const g = clampColorComponent(color.g);\n  const b = clampColorComponent(color.b);\n  return '#' + toHex(r) + toHex(g) + toHex(b);\n}\n\nfunction clampColorComponent(value: number | undefined): number {\n  const normalized = typeof value === 'number' ? value : 0;\n  const scaled = Math.round(normalized * 255);\n  return Math.max(0, Math.min(255, scaled));\n}\n\nfunction toHex(component: number): string {\n  const hex = component.toString(16).toUpperCase();\n  return hex.length === 1 ? '0' + hex : hex;\n}\n\nfunction resolveAliasValues(\n  values: Record<string, SerializedVariableValue | undefined>,\n): Record<string, SerializedVariableValue | undefined> {\n  const result: Record<string, SerializedVariableValue | undefined> = {};\n  if (!values) return result;\n  for (const modeId in values) {\n    if (!Object.prototype.hasOwnProperty.call(values, modeId)) continue;\n    result[modeId] = resolveAliasValue(values[modeId]);\n  }\n  return result;\n}\n\nfunction resolveAliasValue(\n  value: SerializedVariableValue | undefined,\n): SerializedVariableValue | undefined {\n  if (!isVariableAlias(value)) {\n    return value;\n  }\n  const aliasKey = extractAliasKey(value.id);\n  if (!aliasKey || !blueTintVariableMap) {\n    return value;\n  }\n  const target = blueTintVariableMap.get(aliasKey);\n  if (!target) {\n    return value;\n  }\n  for (const resolved of Object.values(target.valuesByMode)) {\n    if (resolved !== undefined) {\n      return resolved;\n    }\n  }\n  return value;\n}\n\nfunction isVariableAlias(\n  value: SerializedVariableValue | undefined,\n): value is VariableAlias {\n  if (!value || typeof value !== 'object') return false;\n  return (value as VariableAlias).type === 'VARIABLE_ALIAS';\n}\n\nfunction extractAliasKey(aliasId?: string): string | null {\n  if (!aliasId) return null;\n  const withoutPrefix = aliasId.replace(/^VariableID:/, '');\n  const [key] = withoutPrefix.split('/');\n  return key || null;\n}\n\nasync function ensureBlueTintVariablesLoaded(): Promise<void> {\n  // Load remote token catalog \u043E\u0434\u0438\u043D \u0440\u0430\u0437 \u0434\u043B\u044F resolve aliases.\n  if (blueTintVariableMap) return;\n  if (blueTintLoadPromise) {\n    return blueTintLoadPromise;\n  }\n  blueTintLoadPromise = (async () => {\n    try {\n      const response = await requestRemoteSource(blueTintTokensUrl);\n      const payload = JSON.parse(response) as TokenExportPayload;\n      blueTintVariableMap = buildBlueTintVariableMap(payload);\n    } catch (error) {\n      console.warn('[Athena] failed to load BlueTint tokens', error);\n      blueTintVariableMap = new Map();\n    } finally {\n      blueTintLoadPromise = null;\n    }\n  })();\n  return blueTintLoadPromise;\n}\n\nfunction buildBlueTintVariableMap(payload: TokenExportPayload): Map<string, TokenVariableExport> {\n  const result = new Map<string, TokenVariableExport>();\n  if (!payload || !Array.isArray(payload.collections)) return result;\n  for (const collection of payload.collections) {\n    for (const variable of collection.variables ?? []) {\n      if (variable.key) {\n        result.set(variable.key, variable);\n      }\n    }\n  }\n  return result;\n}\n\nasync function requestRemoteSource(url: string): Promise<string> {\n  const requestHTTPsAsync = (figma as any)?.requestHTTPsAsync;\n  if (typeof requestHTTPsAsync === 'function') {\n    return requestHTTPsAsync(url);\n  }\n  if (typeof fetch === 'function') {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status} ${response.statusText}`);\n    }\n    return response.text();\n  }\n  throw new Error('\u041D\u0435\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E\u0433\u043E API \u0434\u043B\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0434\u0430\u043D\u043D\u044B\u0445 (fetch/requestHTTPsAsync)');\n}\n\nfunction normalizePageName(name: string): string {\n  if (!name) return '';\n  return name.replace(/^[^A-Za-z0-9\u0410-\u042F\u0430-\u044F\u0401\u0451]+/, '').trim();\n}\n\nfunction sanitizeExportPayload(data: DSExport): DSExport {\n  // \u0423\u0431\u0438\u0440\u0430\u0435\u043C heavy fields \u0438 trim nodes \u043F\u0435\u0440\u0435\u0434 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u043E\u0439 \u0432 UI.\n  const sanitizedComponents = data.components.map((component) => {\n    const sanitizedComponent: DSComponent = Object.assign({}, component, {\n      structure: component.structure.map(trimStructureNode),\n      variantStructures: component.variantStructures\n        ? sanitizeVariantStructures(component.variantStructures)\n        : undefined,\n    });\n    delete sanitizedComponent.parentComponent;\n    delete sanitizedComponent.parentComponents;\n    return sanitizedComponent;\n  });\n  return Object.assign({}, data, { components: sanitizedComponents });\n}\n\nfunction sanitizeVariantStructures(\n  variants: Record<string, DSVariantStructurePatch[]>,\n): Record<string, DSVariantStructurePatch[]> {\n  const result: Record<string, DSVariantStructurePatch[]> = {};\n  for (const key in variants) {\n    const patches = variants[key];\n    result[key] = patches.map(trimVariantPatch);\n  }\n  return result;\n}\n\nfunction trimVariantPatch(patch: DSVariantStructurePatch): DSVariantStructurePatch {\n  if (patch.op === 'update') {\n    return Object.assign({}, patch, {\n      value: trimPatchValue(patch.value),\n    });\n  }\n  if (patch.op === 'add') {\n    return Object.assign({}, patch, {\n      node: trimStructureNode(patch.node),\n    });\n  }\n  return patch;\n}\n\nfunction trimPatchValue(value: DSStructureNodePatch): DSStructureNodePatch {\n  const trimmed: DSStructureNodePatch = {};\n  if ('id' in value) trimmed.id = value.id;\n  if ('path' in value) trimmed.path = value.path;\n  if ('type' in value) trimmed.type = value.type;\n  if ('name' in value) trimmed.name = value.name;\n  if ('visible' in value) trimmed.visible = value.visible;\n  if ('styles' in value) trimmed.styles = value.styles;\n  if ('layout' in value) trimmed.layout = value.layout;\n  if ('opacity' in value) trimmed.opacity = value.opacity;\n  if ('opacityToken' in value) trimmed.opacityToken = value.opacityToken;\n  if ('radius' in value) trimmed.radius = value.radius;\n  if ('radiusToken' in value) trimmed.radiusToken = value.radiusToken;\n  if ('effects' in value) trimmed.effects = value.effects;\n  if ('componentInstance' in value) {\n    trimmed.componentInstance = value.componentInstance;\n  }\n  if ('text' in value) trimmed.text = value.text;\n  if ('fills' in value) trimmed.fills = value.fills;\n  if ('fillToken' in value) trimmed.fillToken = value.fillToken;\n  if ('strokes' in value) trimmed.strokes = value.strokes;\n  if ('strokeToken' in value) trimmed.strokeToken = value.strokeToken;\n  if ('strokeWeight' in value) trimmed.strokeWeight = value.strokeWeight;\n  if ('strokeAlign' in value) trimmed.strokeAlign = value.strokeAlign;\n  if ('typography' in value) trimmed.typography = value.typography;\n  if ('typographyToken' in value) trimmed.typographyToken = value.typographyToken;\n  return trimmed;\n}\n\nfunction trimStructureNode(node: DSStructureNode): DSStructureNode {\n  return {\n    id: node.id,\n    parentId: node.parentId,\n    path: node.path,\n    type: node.type,\n    name: node.name,\n    visible: node.visible,\n    styles: node.styles,\n    layout: node.layout,\n    opacity: node.opacity,\n    opacityToken: node.opacityToken,\n    radius: node.radius,\n    radiusToken: node.radiusToken,\n    effects: node.effects,\n    text: node.text,\n    fills: node.fills,\n    fillToken: node.fillToken,\n    strokes: node.strokes,\n    strokeToken: node.strokeToken,\n    strokeWeight: node.strokeWeight,\n    strokeAlign: node.strokeAlign,\n    typography: node.typography,\n    typographyToken: node.typographyToken,\n    componentInstance: node.componentInstance,\n  };\n}\n"],
  "mappings": "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",
  "names": ["getBoundVariableId", "resolveBindingId", "normalizePageName", "normalizePageName", "_a", "_b", "cloneNode", "normalizePageName", "clampColorComponent", "toHex", "normalizePageName"]
}
